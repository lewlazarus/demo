## Загальний опис рішення

## Структура проєкту
 
* `data` - містить інтерфейс (StorageInterface) для постійного сховища та його імплементацію на базі файлу
* `gen` - містить код для кодо-генерації методів: Sum, Multiple та ін. Призначення -- тест/пошук оптимальних розмірів/порцій обробки даних у масиві
* `generated` - містить результат кодо-генерації
* `msg` - містить структури які репрезентують вхідні та вихідні дані 
* `ops` - містить функції-обгортки над результатом кодогенерації та тести

## Опис ідеї/реалізації

### Ідея #0. "Ні" дефолтним значенням конфігів
З метою уникнення помилок/проблем ми валідуємо значення конфігів і у разі виявлення помилок -- кидаємо паніку і додаток не стартує

Наприклад, якщо не вказано розмір пулу subscription'ів -- рішення не запуститься

### Ідея #1. Генерація коду
З метою спрощення пошуку оптимального розміру batch'ів обробки даних у запитах, код генерується згідно вхідних параметрів. 
Це забезпечує:
1. Швидкість пошуку оптимальних значень 
2. Зменшення кількості помилок, які можна допустити при "рутинній роботі"

Замість стандартних методів Marshal'ізації JSON-об'єтків використовується easyjson (На жаль, це продукт mail.ru )

### Ідея #2. Пул subscription'ів

Для забезпечення асинхронної обробки запитів, створюється пул subscription'ів, які "слухають" запити    

## Шляхи для покращення

### Шлях #0. Обробка у горутинах

Реалізувати "розумну" обробку даних. На основі емпіричних даних (або бенчмарків) використати настуний алгоритм.

Якщо, наприклад, розмір слайсу <= 10000 елементів обробляти його "в лоб" (так як зараз), якщо > 10000 -- запускати обробку у горутинах, 
де кожна з них (горутин) буде обробляти дані в межах "від" та "до" оригінального сласу.

Наприклад, горутина #0 сумує елементи з 0 по N-1, горутина #1 сумує з N по len(values) -1. Після визначається загальна сума 

Кількість горутин та розмір batch'ів може бути визначено емпірично.

### Шлях #1. Добавлення ще одного інстансу

Відбується "підйом" ще одного інстансу додатку і вони разом починають "вичитувати" дані з NATS.

Так як потрібно зберігати попередній результат, необхідно мати централізование сховище і відповідно добавити нову імплементацію 
інтерфейсу `StorageInterface`. У якості такого сховище, як варіант, може бути `Redis`

### Шлях #2. Поєднання перелічених вище шляхів

Поєднання шляхів #0 та #1

